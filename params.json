{
  "name": "Websocket",
  "tagline": "",
  "body": "\r\n## 1. WebSocket 的背景\r\n+ ### Polling\r\n> 采用轮询的方式，浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。\r\n>\r\n>![Alt text](http://img.blog.csdn.net/20130517151509160)\r\n>缺点：需要服务器有很快的处理速度和资源\r\n+ ### Long Polling## \r\n>采用轮询的方式，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。\r\n>\r\n>![Alt text](http://img.blog.csdn.net/20130517151612871)\r\n> 缺点: 需要有很高的并发处理能力\r\n\r\n## 2. WebSocket 是什么\r\n>WebSocket 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯。\r\n+ ### 基于TCP协议\r\n>握手的时序图\r\n>\r\n>![Alt text](https://raw.githubusercontent.com/laubrence/static/master/websocket.gif)\r\n>\r\n+ ### 双向通信\r\n>类似于Socket，服务器和客户端(Browser)都能主动的向对方发送或接收数据\r\n\r\n>传统 HTTP 请求响应客户端服务器交互图 \r\n>\r\n>![Alt text](http://www.ibm.com/developerworks/cn/java/j-lo-WebSocket/img001.jpg \"传统 HTTP 请求响应客户端服务器交互图\")\r\n\r\n>WebSocket 请求响应客户端服务器交互图 \r\n>\r\n>![Alt text](http://www.ibm.com/developerworks/cn/java/j-lo-WebSocket/img002.jpg \"WebSocket 请求响应客户端服务器交互图\")\r\n\r\n\r\n\r\n## 3. WebSocket 机制\r\n+ WebSocket 客户端连接报文\r\n```\r\nGET /chat HTTP/1.1\r\nHost: server.example.com\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\r\nSec-WebSocket-Protocol: chat, superchat\r\nSec-WebSocket-Version: 13\r\nOrigin: http://example.com\r\n```\r\n\r\n+ WebSocket 服务端响应报文\r\n```\r\nHTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=\r\nSec-WebSocket-Protocol: chat\r\n```\r\n\r\n+ WebSocket API\r\n> 客户端API\r\n```\r\nvar ws = new WebSocket(“ws://echo.websocket.org”);\r\nws.onopen = function(){ws.send(“Test!”); };\r\nws.onmessage = function(evt){console.log(evt.data);ws.close();};\r\nws.onclose = function(evt){console.log(“WebSocketClosed!”);};\r\nws.onerror = function(evt){console.log(“WebSocketError!”);};\r\n```\r\n>\r\n>服务器API\r\n```\r\n @ServerEndpoint(\"/echo\")\r\n public class EchoEndpoint {\r\n\r\n @OnOpen\r\n public void onOpen(Session session) throws IOException {\r\n //以下代码省略...\r\n }\r\n \r\n @OnMessage\r\n public String onMessage(String message) {\r\n //以下代码省略...\r\n }\r\n\r\n @Message(maxMessageSize=6)\r\n public void receiveMessage(String s) {\r\n //以下代码省略...\r\n } \r\n\r\n @OnError\r\n public void onError(Throwable t) {\r\n //以下代码省略...\r\n }\r\n \r\n @OnClose\r\n public void onClose(Session session, CloseReason reason) {\r\n //以下代码省略...\r\n } \r\n }\r\n```\r\n>Tomcat从7.0.27开始支持 WebSocket，从7.0.47开始支持JSR-356\r\n\r\n## 4. WebSocket 应用场景\r\n> 决定手头的工作是否需要使用WebSocket技术的方法很简单：\r\n+ 你的应用提供多个用户相互交流吗？\r\n+ 你的应用是展示服务器端经常变动的数据吗？\r\n\r\n> 应用场景\r\n1. WebIM\r\n> 新浪微博 [私信聊天](http://weibo.com/)\r\n2. 在线聊天室 \r\n>[聊天室demo](http://chat.workerman.net/)\r\n3. 多玩家游戏\r\n>[小蝌蚪游戏](http://kedou.workerman.net/)\r\n>\r\n>[BrowserQuest](http://browserquest.mozilla.org/)\r\n4. 视频直播弹幕\r\n>[摄像头录制页面](http://www.workerman.net/demos/live-camera/camera.html)\r\n>\r\n>[实时接收视频流页面](http://www.workerman.net/demos/live-camera/)\r\n5. WEB消息推送\r\n>[推送demo](http://www.workerman.net:2123/)\r\n6. 基于位置的应用\r\n7. 社交订阅\r\n1. 协同编辑\r\n1. ...\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}